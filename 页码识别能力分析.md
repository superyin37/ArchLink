# 页码识别能力全面分析

## 一、两种识别模式

### 1. **PageByAnchorExtractor（锚点识别器）**
基于规范号锚点的局部搜索

**正则表达式：**
```python
PAGE_PATTERN = r"^[A-Z]?\d+$"
```

**能识别的格式：**
- ✅ `C11` - 字母+数字
- ✅ `P5` - 字母+数字
- ✅ `11` - 纯数字
- ✅ `5` - 单数字
- ✅ `123` - 多位数字

**不能识别的格式：**
- ❌ `C11-2` - 包含连字符
- ❌ `1-11` - 纯数字带连字符
- ❌ `AB11` - 多个字母前缀

**限制条件：**
- 置信度必须 ≥ 0.5 (`conf_min`)
- 必须在规范号锚点 120 像素范围内 (`radius`)
- 必须先找到规范号锚点（格式：`\d{2,3}\s*[A-Z]\s*\d+`，如 12J2）

---

### 2. **LegacyPageCodeParser（旧版解析器）**
分前缀-后缀组合识别

#### 2.1 前缀识别（PREFIX）
**正则表达式：**
```python
PAGE_PREFIX_PATTERN = r"([A-Z])(\d{1,3})"
```

**能识别的前缀：**
- ✅ `C11` - 单字母+1-3位数字
- ✅ `P5` - 单字母+数字
- ✅ `A123` - 单字母+3位数字

**不能识别：**
- ❌ `11` - 纯数字（会被识别为 suffix）
- ❌ `AB11` - 多个字母

#### 2.2 后缀识别（SUFFIX）
**正则表达式：**
```python
r"^\d{1,2}$"
```

**能识别的后缀：**
- ✅ `1` - 单数字
- ✅ `11` - 两位数字
- ✅ 置信度必须 > 0.7

**不能识别：**
- ❌ `123` - 三位数字（超出 `\d{1,2}` 限制）

#### 2.3 组合逻辑（已修复）
**修复前的问题：**
- 只输出 prefix 页码
- suffix（纯数字）不会被单独输出

**修复后的行为：**
1. 优先组合：`prefix + suffix` → `C11-2`
2. 单独 prefix（无匹配 suffix）→ `C11`
3. **✅ 新增：单独 suffix（未被组合）→ `11`**

---

## 二、文件索引的页码提取

在 `database/file_index.py` 中，从文件名提取页码：

**支持的模式（按优先级）：**
```python
patterns = [
    r'_([A-Z]\d+(?:-\d+)?)',  # _C11, _C11-2, _P5-3
    r'_(\d+-\d+)',             # _1-11, _5-2
    r'_([A-Z]+\d+)',           # _ABC123
    r'_(\d+)',                 # _11, _5, _123
]
```

**能提取的页码格式：**
- ✅ `23J909_C11.pdf` → `C11`
- ✅ `23J909_C11-2.pdf` → `C11-2`
- ✅ `23J909_1-11.pdf` → `1-11`
- ✅ `23J909_11.pdf` → `11`
- ✅ `23J909_5.pdf` → `5`
- ✅ `23J909_123.pdf` → `123`

---

## 三、完整识别流程

```
OCR识别图片
    ↓
找到规范号锚点？
    ├─ 是 → PageByAnchorExtractor (锚点识别)
    │       └─ 在锚点附近找符合 [A-Z]?\d+ 的文本
    │           └─ 输出：C11, 11, 5 等
    │
    └─ 否 → LegacyPageCodeParser (旧版识别)
            ├─ 识别 prefix: [A-Z]\d{1,3}  → C11, P5
            ├─ 识别 suffix: \d{1,2} (conf>0.7) → 1, 11, 2
            └─ 组合逻辑：
                ├─ 有配对 → C11-2
                ├─ prefix单独 → C11
                └─ suffix单独 → 11 (修复后新增)
```

---

## 四、当前支持的页码格式总结

### ✅ 能够识别：
1. **字母+数字**
   - `C11`, `P5`, `A123`
   
2. **纯数字（锚点模式）**
   - `11`, `5`, `123`（需要有规范号锚点在附近）
   
3. **纯数字（旧版模式 - 修复后）**
   - `1`, `11`（1-2位，置信度>0.7）
   - ⚠️ 不支持 `123`（3位数字，超出 `\d{1,2}` 限制）

### ❌ 不能识别（OCR解析阶段）：
1. **带连字符的页码**
   - `C11-2`, `1-11`, `5-2`
   - 原因：`PAGE_PATTERN` 不包含连字符

2. **多字母前缀**
   - `AB11`, `ABC123`
   - 原因：`PAGE_PREFIX_PATTERN` 只匹配单字母

3. **三位纯数字（旧版模式）**
   - `123`, `456`
   - 原因：suffix 正则限制为 `\d{1,2}`

---

## 五、识别能力与文件索引的匹配度

### 文件命名支持但识别可能失败的情况：

| 文件名格式 | 文件索引提取 | OCR能识别？ | 问题 |
|-----------|------------|-----------|------|
| `23J909_1-11.pdf` | ✅ `1-11` | ❌ | PAGE_PATTERN 不包含连字符 |
| `23J909_C11-2.pdf` | ✅ `C11-2` | ❌ | PAGE_PATTERN 不包含连字符 |
| `23J909_123.pdf` | ✅ `123` | ⚠️ | 锚点模式✅ / 旧版❌（超出\d{1,2}）|
| `23J909_11.pdf` | ✅ `11` | ✅ | 都支持 |
| `23J909_C11.pdf` | ✅ `C11` | ✅ | 都支持 |

---

## 六、建议的改进方案

### 方案 1: 扩展 PAGE_PATTERN 支持连字符
```python
# 修改前
PAGE_PATTERN = re.compile(r"^[A-Z]?\d+$", re.IGNORECASE)

# 修改后
PAGE_PATTERN = re.compile(r"^[A-Z]?\d+(?:-\d+)?$", re.IGNORECASE)
```
**影响：** 能识别 `C11-2`, `1-11`, `11-5` 等格式

### 方案 2: 放宽旧版 suffix 限制
```python
# 修改前
if re.match(r"^\d{1,2}$", text) and box.confidence > 0.7:

# 修改后
if re.match(r"^\d{1,3}$", text) and box.confidence > 0.7:
```
**影响：** 旧版模式也能识别3位纯数字 `123`

### 方案 3: 支持多字母前缀
```python
# 修改前
PAGE_PREFIX_PATTERN = r"([A-Z])(\d{1,3})"

# 修改后
PAGE_PREFIX_PATTERN = r"([A-Z]{1,3})(\d{1,3})"
```
**影响：** 能识别 `AB11`, `ABC123` 等格式

---

## 七、测试建议

创建测试用例覆盖：
1. 纯数字页码（1, 11, 123）
2. 带连字符页码（1-11, C11-2）
3. 不同置信度的文本
4. 有/无规范号锚点的场景
5. 多字母前缀（AB11）

